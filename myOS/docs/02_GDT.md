<!--
 * @Author: Alan Yin
 * @Date: 2024-05-03 18:30:56
 * @LastEditTime: 2024-05-05 21:20:24
 * @LastEditors: Alan Yin
 * @FilePath: /myOS/docs/02_GDT.md
 * @Description:
 * // -*- mode:C; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
 * // vim: ts=8 sw=2 smarttab
 * Copyright (c) 2024 by Alan Yin, All Rights Reserved.
-->

https://zhuanlan.zhihu.com/p/561358124
https://blog.csdn.net/abc123lzf/article/details/109289567

### 1.GDT 概述
和一个段有关的信息需要 8 个字节来描述，所以称为段描述符（Segment Descriptor），每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个描述符表。
最主要的描述符表是全局描述符表（Global Descriptor Table， GDT）(64KB)，所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。
理论上，全局描述符表可以位于内存中的任何地方。但是，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义 GDT。但是，由于在实模式下只能访问 1MB 的内存，故 GDT 通常都定义在 1MB 以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义 GDT。
为了跟踪全局描述符表，处理器内部有一个 48 位的寄存器，称为全局描述符表寄存器（GDTR）。这 48 位内存数据划分为两部分 前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于GDT 的字节大小减 1。 * 换句话说就是表内最后一个字节的偏移量 后 32 位是 GDT 的起始地址。

![GDT寄存器](https://pic4.zhimg.com/v2-be3a76f5b4f39fdb5d7d47f66c1af8ef_r.jpg)

由于 GDT 的大小是 16 位二进制，其表示的范围是 2的16次方等于65536字节(64KB)。每个描述符大小是8字节，故 GDT中最多可容纳的描述符数量是65536/8=8192个，即 GDT 中可容纳 8192 个段或门。

![GDT](https://pic2.zhimg.com/v2-2ed786348410c8a5b22587d71ec76d19_r.jpg)

![GDT Type](https://pic3.zhimg.com/v2-71fa9036fabc551926c9df093b1bd05a_r.jpg)

### 2.加载 GDT
操作这个寄存器使用 lgdt命令。
lgdt m48;
该指令在16位模式下，该地址是16位的，在32模式下，该地址是32位的。
描述符不是由用户程序自己创建的，而是在加载时，有操作系统为你创建的，用户程序无法建立和修改GDT。

### 3.选择子
在 32 位模式下，传统的段寄存器，如 CS、 SS、 DS、 ES，保存的不再是 16位段基地址，而是段的选择子，即，用于选择所要访问的段，因此，严格地说，它的新名字叫做段选择器。除了段选择器之外，每个段寄存器还包括一个 64 位的不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。
段寄存器内容空出来了，放的就是selector,选择子。
选择子是个索引值，此索引值在段描述符表中索引相应的段描述符，这样，便在段描述符中得到了内存段的起始地址和段界限值等相关信息。
由于段寄存器是 16 位，所以选择子也是 16 位。

![段选择子](https://pic2.zhimg.com/v2-9558bf1f5c815300e981a57b76d3e90d_r.jpg)

|   描述符索引值    |  TI  |  RPL  |
15                 3      2       0

RPL，即请求特权级，可以表示 0、 1、 2、 3 四种特权级。
TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是在 LDT 中的索引描述符。TI为 0 表示在 GDT 中索引描述符， TI 为 1 表示在 LDT 中索引描述符。
选择子的高 13 位（可以表示 8K 个记录，正好是 GDT 中可容纳的段或门数量），即第 3～15 位是描述符的索引值，用此值在 GDT 中索引描述符。前面说过 GDT 相当于一个描述符数组，所以此选择子中的索引值就是 GDT 中的下标。

例如选择子是 0x8，将其加载到 ds 寄存器后，访问 ds:0x9 这样的内存，其过程是： 0x8 的低 2 位是RPL，其值为 00。第 2 是 TI，其值 0，表示是在 GDT 中索引段描述符。 用 0x8 的高 13 位 0x1 在 GDT 中索引，也就是 GDT 中的第 1 个段描述符（GDT 中第 0 个段描述符不可用）。假设第 1 个段描述符中的 3个段基址部分， 其值为 0x1234。CPU 将 0x1234 作为段基址， 与段内偏移地址 0x9 相加， 0x1234+0x9=0x123d。

### 4.进入保护模式
进入保护模式需要经历三个步骤： 1. 注册段 2. 打开A20地址线 3. 保护模式的开关，CR0 寄存器的 PE 位。
（1）lgdt
lgdt 的指令格式是： lgdt48 位内存数据; 前16+后32位
```
; mov bx 0x7e00
;创建0#描述符，它是空描述符，这是处理器的要求
mov dword [bx+0x00],0x00
mov dword [bx+0x04],0x00

;创建#1描述符，保护模式下的代码段描述符
mov dword [bx+0x08],0x7c0001ff  ;低32位
mov dword [bx+0x0c],0x00409800 ;高32位

;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
mov dword [bx+0x10],0x8000ffff
mov dword [bx+0x14],0x0040920b

;创建#3描述符，保护模式下的堆栈段描述符
mov dword [bx+0x18],0x00007a00
mov dword [bx+0x1c],0x00409600
```
（2）打开A20地址线
[打开A20地址线](https://www.cnblogs.com/mqmelon/p/4790820.html)
1）Keyboard Controller. 1、通过键盘控制器
2）BIOS Function. 2、调用BIOS功能
3）System Port.
在 OS 的 boot 阶段一般都要做打开 A20 gate 操作，虽然现在 A20 gate 缺省为开的。

实模式下的 wrap-around（地址回绕） 实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以 16 后再加上段内偏移地址。实模式下寄存器都是 16 位的，如果段基址和段内偏移地址都为 16 位的最大值，即 0xFFFF： 0xFFFF，最大地址是 0xFFFF0+0xFFFF， 即 0x10FFEF。由于实模式下的地址线是 20 位， 最大寻址空间是 1MB， 即 0x00000～0xFFFFF。超出 1MB 内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。
但 80286 有 24 条地址线，即 A0～A23，也就是说 A20 地址线是开启的。如果访问 0x100000～0x10FFEF 之间的内存，系统将直接 访问这块物理内存，并不会像 8086/8088 那样回绕到 0。
为了解决此问题， IBM 在键盘控制器上的一些输出线来控制第 21 根地址线（A20）的有效性，故被称为 A20Gate。
* 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时， CPU 将真正访问这块物理内存。
* 如果 A20Gate 被禁止， 当访问 0x100000～0x10FFEF 之间的地址时， CPU 将采用 8086/8088 的地址回绕。

开启a20
```
in al， 0x92
or al， 0000_0010B
out 0x92， al
```
(3)保护模式的开关，CR0 寄存器的 PE 位
 CR0寄存器的第 0 位，即 PE 位， Protection Enable，此位用于启用保护模式，当打开此位后， CPU 才真正进入保护模式。
![CR0](https://pic4.zhimg.com/v2-d346e166271cf951103dd1b508729083_r.jpg)

PE 为 0 表示在实模式下运行， PE 为 1 表示在保护模式下运行。
```
mov eax, cr0       ; 将 cr0 写入 eax。
or eax, 0x00000001 ; 通过或运算 or 指令将 eax 的第 0 位置 1。
mov cr0, eax       ; 将 eax 写回 cr0，这样 cr0 的 PE 位便为 1 了。
```

(4)调试
使用 bochsdbg -q -f bochsrc.bxrc 运行程序，然后按下 c, Ctrl + C, 输入 info gdt;

# 5.GDT 和 LDT
描述符表有 2 种：全局描述符表（GDT）和 局部描述符表（LDT）。全局描述符表（GDT）是全局性的，是为所有任务服务的，所以有一个就够了。局部描述符表（LDT）的数量可以不止一个，具体有多少，视任务数量而定。为了追踪这 2 种描述符表，处理器内部提供了全局描述符表寄存器（GDTR）和局部描述符表寄存器（LDTR） 。

GDTR 中存储了全局描述符表（GDT）的基地址（保护模式下为 32位，IA-32e 模式下为 64位）和16 位的表限制 。

![GDTR](https://pic4.zhimg.com/v2-4fba96f29df0216627ca37dc8ceb210b_r.jpg)

局部描述符表（LDT）是作为全局描述符表（GDT）的一个段而存在的。LDTR 中保存了该段的段选择子（16 位），基地址（保护模式下为 32位，IA-32e 模式下为 64位），段限制（16 位）和段属性 。LDTR 本质上，是一个段寄存器，其格式如下：

![LDTR](https://pic2.zhimg.com/v2-5545e88da259e00646d33f4f20c0b0d9_r.jpg)