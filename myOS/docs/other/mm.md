保护模式下的内存管理
====================
* 一个段有一个基地址（Base Address）,大小由界限（limit）决定
* 保护模式下的段允许自定义段的位置和段的长度


全局描述符表（GDT）
==================
* 它是一块内存空间，最大64KiB
* 可以理解为一个数组，里面的每一个元素是个段描述符
* 全局描述符的地址指针会被放在一个特殊的寄存器里——GDTR
* GDTR是一个48位的寄存器，因为全局描述符的地址指针大小也是48位
[ 0-15位]: GDT的长度，所以GDT最大为64KB;
[16-47位]: GDT的起始地址;


段描述符（SD, Segment Descriptor）
=================================
* 描述段的属性
* 每个段描述符为8个字节，64位，两个dword（字的大小与架构有关）
* 低32位：
[ 0-15位]: 段大小的0-15位，或者段边界（Limit）;
[16-31位]: 段基地址的0-15位（线性地址，Base）；
* 高32位：
[ 0- 7位]: 段基地址的15-23位；
[24-31位]: 段基地址的24-31位；
[16-19位]: 段大小的16-19位；
[   23位]: G（Granularity, 粒度），表明段大小的单位；
   G=0，单位为1B，段大小最大为1MB；
   G=1，单位为4KB，段大小最大为4GB； 
[   12位]: S，段的类型；
   S=0，系统段；
   S=0，代码段或数据段；
[   15位]: P，指示段是否在内存中，涉及到虚拟内存；
[13-14位]: DPL（Descriptor Privilege Level），指示段的权限级别；
   DPL=00，Ring0级别，最高权限（内核）；
   DPL=01，Ring1级别；
   DPL=10，Ring2级别；
   DPL=11，Ring3级别，最低权限；
[   21位]: L，表明该段是否包含64位代码；
   L=0，包含；
   L=1，不包含；
[   20位]: AVL，软件保留位，可随便填数字。
[   22位]: D/B，默认操作数的大小，默认栈指针大小或者默认上部边界，用于向下兼容16位程序；
[ 8-11位]: Type，描述符的类型；11位（X），12位（E/C），13位（W/R），14位（A）；
	取值为'XEWA'或者'XCRA'
	X=0，该段为数据段
		E表示拓展方向（Expansion-direction），用于栈段（也算一种数据段）
			E=0，向上拓展；
			E=1，向下拓展；
		W表示该段是否可写（Write-enable）
			W=0，只读
			W=1，读写
	X=1，该段为代码段
		C表示是否顺从权限级别（Conforming）
			C=0，只允许被处在相同特权级的段里的代码调用；
			C=1，允许低特权的段调用，调用时，调用者的CPL不变；
		R：是否可读（Read-enable）
		A：是否被访问（Accessed）
			由CPU动态设置，每当这个段被访问后，这个位就会被拉高A=1；


CPU如何追踪程序的特权
=====================
CPL（Current Privilege Level）：看寄存器CPL的值，它记录了当前正在运行的程序的特权级。
CPL不总是等于DPL。


寻址
====
* 实模式寻址
段基地址+段内偏移，段基地址需要通过GDT查询得到。
* 保护模式寻址
逻辑地址的长度为48位，由一个16位的段选择器（Segment Selector）以及32位的段内偏移构成。
段选择器不是GDT内的偏移。
* 寻址流程的伪代码为：
	getLinearAddr(logic_addr):
	ss, offset = logic_addr
	index, ti, rpl = ss
	table = []
	if ti is set:
		table = LDT
	else:
		table = GDT
	SD = table[index * 8]
	
	if SD == null or not '使用rpl判断是否有权限访问SD':
		throw GP
	return sd.base + offset


段选择器（SS，Segment Selector）
===========================
* 16位的段选择器内容如下：
	[ 3-15位]: Index，段的索引，表示第几个SD（段描述符，SD, Segment Descriptor），就像数组操作，范围为0-8191，代表GDT中8192个SD；64*1024/8=8192；第一个SD（索引为0）是一个空的SD，若使用这个SD寻址，CPU将产生一个GP（General Protection）异常，直接导致Triple Fault。
	[    2位]: TI，表指示器（Table Indicator）；
	TI=0，这个段描述符在GDT里；
	TI=1，这个段描述符在LDT里；（用得少）
[ 0- 1位]: RPL，请求权限级，段选择器的权限，RPL=CPL；
	RPL=00，Ring0；
	RPL=01，Ring1；
	RPL=10，Ring2；
	RPL=11，Ring3；


注意事项
============================
* 32为模式下依然是16位的寄存器：
CS，ES，SS，DS
实模式下它们存放的是段地址，段地址+偏移地址
保护模式下它们存放的是段选择器，段选择器+偏移地址
* 保护模式下赠送的两个段寄存器：
FS，GS



分页
====

* 分页在保护模式下才开启
* 分页默认不启用
* 通过设置CR0寄存器的PG位可以开启分页
* 有三种分页模式
  1. 32位分页
  2. PAE分页
  3. 4层分页（用于IA--32e模式）
* 在这种模式下
  * 32位线性地址
  * 40位物理地址（与PSE，Page Size Extension有关系）
  * 每页大小可以是4KB或者4MB
