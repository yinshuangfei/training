<!--
 * @Author: Alan Yin
 * @Date: 2024-05-05 22:30:39
 * @LastEditTime: 2024-05-05 23:09:56
 * @LastEditors: Alan Yin
 * @FilePath: /myOS/docs/04_内联汇编.md
 * @Description:
 * // -*- mode:C; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
 * // vim: ts=8 sw=2 smarttab
 * Copyright (c) 2024 by Alan Yin, All Rights Reserved.
-->

gcc 内联汇编的格式如下：
```
asm ( 汇编语句
    : 输出操作数            // 非必需
    : 输入操作数            // 非必需
    : 其他被污染的寄存器     // 非必需
    );
```

1. 语法规则
asm [volatile] ("汇编指令")
volatile 是可选的，编译器有可能对汇编代码进行优化，使用 volatile 关键字之后，告诉编译器不要优化手写的内联汇编代码。

gcc_add.c
```
#include <stdio.h>

int main()
{
    int a=1, b=2, c=0;

    asm(
        "addl %2, %0"		// 1
        : "=g"(c)			// 2
        : "0"(a), "g"(b)	// 3
        : "memory");		// 4

    printf("现在c是:%d\n", c);
    return 0;
}
```
输出为 3.

内联汇编中：
 * 第1行是汇编语句，用双引号引起来， 多条语句用 ; 或者 \n\t 来分隔。
 * 第2行是输出操作数，都是 "=?"(var) 的形式， var 可以是任意内存变量（输出结果会存到这个变量中）， ? 一般是下面这些标识符 （表示内联汇编中用什么来代理这个操作数）：
    * a,b,c,d,S,D 分别代表 eax,ebx,ecx,edx,esi,edi 寄存器
    * r 上面的寄存器的任意一个（谁闲着就用谁）
    * m 内存
    * i 立即数（常量，只用于输入操作数）
    * g 寄存器、内存、立即数 都行（gcc你看着办）
在汇编中用 %序号 来代表这些输入/输出操作数， 序号从 0 开始。为了与操作数区分开来， 寄存器用两个%引出，如：%%eax

 * 第3行是输入操作数，都是 "?"(var) 的形式， ? 除了可以是上面的那些标识符，还可以是输出操作数的序号， 表示用 var 来初始化该输出操作数， 上面的程序中 %0 和 %1 就是一个东西，初始化为 1（a的值）。
 * 第4行标出那些在汇编代码中修改了的、 又没有在输入/输出列表中列出的寄存器， 这样 gcc 就不会擅自使用这些"危险的"寄存器。 还可以用 "memory" 表示在内联汇编中修改了内存， 之前缓存在寄存器中的内存变量需要重新读取。

　　上面这一段内联汇编的效果就是， 把a与b的和存入了c。当然这只是一个示例程序， 谁要真这么用就蛋疼了， 内联汇编一般在不得不用的情况下才使用。


使用占位符来代替寄存器名称：
```
#include <stdio.h>
int main()
{
    int data1 = 1;
    int data2 = 2;
    int data3;

    asm("addl %1, %2\n\t"
        "movl %2, %0"
        : "=r"(data3)
        : "r"(data1),"r"(data2));

    printf("data3 = %d \n", data3);
    return 0;
}
```
输出为 3.

汇编代码如下：
```
    movl	$1, -20(%ebp)
    movl	$2, -16(%ebp)
    movl	-20(%ebp), %eax
    movl	-16(%ebp), %edx
#APP
# 10 "test6.c" 1
    addl %eax, %edx
    movl %edx, %eax
# 0 "" 2
#NO_APP
    movl	%eax, -12(%ebp)
```
代码说明：
 * 输出操作数列表"=r"(data3)：约束使用字符 r, 也就是说不指定寄存器，由编译器来选择使用哪个寄存器来存储结果，最后复制到局部变量 data3中；
 * 输入操作数列表"r"(data1),"r"(data2)：约束字符r, 不指定寄存器，由编译器来选择使用哪 2 个寄存器来接收局部变量 data1 和 data2；
 * 输出操作数列表中只需要一个寄存器，因此在内联汇编代码中的 %0 就代表这个寄存器(即：从 0 开始计数)；
 * 输入操作数列表中有 2 个寄存器，因此在内联汇编代码中的 %1 和 %2　就代表这 2 个寄存器(即：从输出操作数列表的最后一个寄存器开始顺序计数)；　