# 数据结构及算法

数据结构和算法不能分开，二者相互融合，不可分离。算法的实现依赖具体的数据结构，靠数据结构承载。



Data Structure：
- List
- Array
- String
- Queue
- Hash Table
- Tree
- Graph
- ...

Algorithms:
- Sort
- Search
- ...

# List (Linked List)
- 单向链表
- 双向链表
- 循环链表（单向、双向）

# Array
数组方便实现栈和队列。

数组和链表结构是基础结构，散列表、栈、队列、堆、树、图等等各种数据结构都基
于数组和链表结构实现。



基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度≥3的数组）等。
基于链表可实现：栈、队列、哈希表、树、堆、图等。



# String
- 字符串查找
    - BF算法
    - KMP算法
    - BM算法
- 正则表达式
- 数据压缩
- 排序

# Queue
- 队列
- 堆栈

# Hash Table
分为两个关键点：
1）散列函数；
    散列函数就是将键转化为数组索引的过程。且这个函数应该易于计算且能够均匀
    分布所有的键。方法有：直接定值法、除留余数法、数字分析法、平方取中法、折叠法。
2）碰撞解决；

- 开放地址法（线性探测法）
    使用大小为M的数组保存N个键值对，当碰撞发生时，直接检查散列表中的下一个
    位置，如果发现空位置插入新元素。查找key时，先通过 hash(key) 得到 index，
    看index 处 key 是否已经存在，不存在，就向后遍历数组。
- 链式地址法（拉链法）
    将大小为M的数组中的每个元素指向一条链表，链表中的每个节点都存储了散列值
    为该元素索引的键值对。每条链表的平均长度是N/M，N是键值对的总个数。
    3）扩容和缩容（非关键点）
    当hash表保存的键值对数量太多或太少，对hash 表进行扩容和缩容。合理控制内存
    的使用。

# Tree
- 二叉查找树BST
- 平衡二叉AVL树（绝对平衡二叉树）
- 红黑树（弱平衡二叉树）
- B树
- B+树（mysql 索引使用）
- 字典树（也叫前缀树，单词查找树）
- 二叉堆（堆被称为优先队列）
    堆用数组存储。
- 伸展树（自平衡二叉排序树）
- 后缀树
- 斐波那契堆（Fibonacci Heap）
- 最优二叉树（赫夫曼树）

# Gruph
- 最小生成树
- 最短路径（Floyd, Dijkstra, bellman-ford, spfa）
- 旅行商
- 拓扑排序
- DFS
    深度优先搜索，用递归的形式，用到了栈结构，先进后出;
- BFS
    广度优先搜素，用队列的形式，先进先出。

# Sort
## 交换排序算法
- 冒泡排序
- 插入排序 (√)
- 选择排序
- 希尔排序 (√)
- 快速排序
    二叉树的前序遍历;
- 归并排序
    二叉树的后序遍历;
- 堆排序（优先队列排序）
    大顶堆排序，得到升序排列；
    小顶堆排序，得到降序排列；
## 线性排序算法
- 桶式排序
## 其他
- 计数排序
- 基数排序
- 外部排序

# Search
- 顺序查找
- 二分查找
- 哈希查找
- 分块查找
    块内无序，块之间有序；可以先二分查找定位到块，然后再到块中顺序查找；
- 动态查找
    二叉排序树，AVL树，B- ，B+（这里之所以叫 动态查找表，是因为表结构是查找
    的过程中动态生成的）；

# 高级数据结构
- 自顶向下伸展树
- 红黑树
- 确定性跳跃表
- AA-树
- treap树
- k-d树
- 配对堆

# 算法设计思想
- 贪婪算法（贪心算法）
- 分治算法
- 动态规划算法
- 随机化算法
- 回溯算法
- 递归算法
    递归与循环可以相互替换。递归实现空间开销较大，循环实现空间开销小。递归
    程序的执行一般而言，比循环程序慢。
- 迭代算法
- 穷举搜索算法

# 应用
## 1.海量数据处理
- Hash映射/分而治之
- Bitmap
- Bloom filter(布隆过滤器)
- Trie树
- 数据库索引
- 倒排索引(Inverted Index)
- 双层桶划分
- 外排序
- simhash算法
- 分布处理之Mapreduce

## 开源项目中的算法
- YYCache
- cocos2d-objc
- bitcoin
- geohash
- kafka
- nginx
- zookeeper

